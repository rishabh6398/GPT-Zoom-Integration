"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var api_client_1 = require("@symblai/api-client");
var config_1 = __importDefault(require("../config"));
var ErrorHandler_1 = __importDefault(require("./ErrorHandler"));
var Logger_1 = __importDefault(require("../logger/Logger"));
var OAuth2 = /** @class */ (function () {
    function OAuth2(options) {
        if (options === void 0) { options = {}; }
        this.apiClient = new api_client_1.ApiClient();
        var basePath = options.authBasePath || config_1["default"].authBasePath || options.basePath || config_1["default"].basePath;
        this.setBasePath(basePath);
        this.appId = null;
        this.appSecret = null;
        this.activeToken = null;
        this.updatedOn = null;
        this.expiresOn = null;
        this.expiresIn = null;
        if (options.hasOwnProperty('automaticallyRefreshToken')) {
            this.automaticallyRefreshToken = options.automaticallyRefreshToken;
        }
        else {
            this.automaticallyRefreshToken = true;
        }
        // seconds
        this.refreshTimeBeforeExpiry = options.refreshTimeBeforeExpiry ||
            config_1["default"].refreshTimeBeforeExpiry ||
            300;
        this.refreshOn = null;
        this.refreshTimeoutRef = null;
        this.init = this.init.bind(this);
        this.processTokenResult = this.processTokenResult.bind(this);
        this.validateToken = this.validateToken.bind(this);
        this.refreshAuthToken = this.refreshAuthToken.bind(this);
        this.setBasePath = this.setBasePath.bind(this);
    }
    OAuth2.prototype.setBasePath = function (basePath) {
        this.apiClient.basePath = basePath;
        this.authenticationApi = new api_client_1.AuthenticationApi(this.apiClient);
    };
    OAuth2.prototype.getApiClient = function () {
        return this.apiClient;
    };
    OAuth2.prototype.processTokenResult = function (data) {
        var _this = this;
        var accessToken = data.accessToken, expiresIn = data.expiresIn;
        this.activeToken = accessToken;
        Logger_1["default"].trace('Token received.');
        this.apiClient.authentications.jwt.apiKey = this.activeToken;
        this.expiresIn = expiresIn;
        Logger_1["default"].trace('Token will expire in seconds: ', this.expiresIn);
        this.updatedOn = new Date();
        Logger_1["default"].trace('Token updated on: ', this.updatedOn);
        this.expiresOn = new Date(this.updatedOn.getTime() + this.expiresIn * 1000);
        Logger_1["default"].trace('Token will expire on : ', this.expiresOn);
        if (this.automaticallyRefreshToken) {
            this.refreshOn = new Date(this.expiresOn.getTime() - this.refreshTimeBeforeExpiry * 1000);
            Logger_1["default"].trace('Token will be refreshed on: ', this.refreshOn);
            // const refreshDuration = moment.duration(this.refreshOn.diff(this.updatedOn)).asMilliseconds(); // In milliseconds
            var refreshDuration = (this.expiresIn - this.refreshTimeBeforeExpiry) * 1000;
            Logger_1["default"].trace('Refresh is scheduled in millis: ', refreshDuration);
            if (refreshDuration < 0) {
                refreshDuration = this.expiresIn * 1000;
            }
            if (this.refreshTimeoutRef) {
                clearTimeout(this.refreshTimeoutRef);
            }
            this.refreshTimeoutRef = setTimeout(function () {
                _this.init(_this.appId, _this.appSecret)
                    .then((function () {
                    Logger_1["default"].trace('Token refreshed');
                }))["catch"](function (e) {
                    Logger_1["default"].error(e);
                });
            }, refreshDuration);
        }
    };
    OAuth2.prototype.refreshAuthToken = function () {
        return this.validateToken(this.activeToken);
    };
    OAuth2.prototype.validateToken = function (token) {
        var _this = this;
        return new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
            var tokenPayload, expiry, tokenData, e_1, data, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 12, , 13]);
                        if (!!!token) return [3 /*break*/, 10];
                        tokenPayload = JSON.parse(Buffer.from(token.split('.')[1], 'base64').
                            toString());
                        if (!tokenPayload.exp) return [3 /*break*/, 8];
                        expiry = Math.floor(tokenPayload.exp - Date.now() / 1000);
                        if (!(expiry <= 60)) return [3 /*break*/, 7];
                        if (!(this.appId && this.appSecret)) return [3 /*break*/, 5];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.init(this.appId, this.appSecret)];
                    case 2:
                        tokenData = _a.sent();
                        this.processTokenResult(tokenData);
                        resolve(tokenData);
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _a.sent();
                        Logger_1["default"].error("Exception caught while refreshing token: ".concat(e_1 && e_1.message));
                        reject({
                            message: "The authentication token failed with exception: ".concat(e_1 && e_1.message)
                        });
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                    case 5:
                        reject({
                            message: "Provided token has expired"
                        });
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                    case 7:
                        data = {
                            accessToken: token,
                            expiresIn: expiry
                        };
                        this.processTokenResult(data);
                        resolve(data);
                        return [3 /*break*/, 9];
                    case 8:
                        reject({
                            message: "Provided token is invalid"
                        });
                        _a.label = 9;
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        reject({
                            message: "Provided token was empty, undefined or null"
                        });
                        _a.label = 11;
                    case 11: return [3 /*break*/, 13];
                    case 12:
                        e_2 = _a.sent();
                        Logger_1["default"].warn("Token regeneration failed with error: ".concat(e_2 && e_2.message));
                        resolve();
                        return [3 /*break*/, 13];
                    case 13: return [2 /*return*/];
                }
            });
        }); });
    };
    OAuth2.prototype.init = function (appId, appSecret, token) {
        var _this = this;
        if (!appId) {
            appId = this.appId;
        }
        if (!appSecret) {
            appSecret = this.appSecret;
        }
        if (!token) {
            token = this.activeToken;
        }
        if (!appId && !token) {
            throw new Error('appId is required.');
        }
        if (!appSecret && !token) {
            throw new Error('appSecret is required.');
        }
        if ((!appId || !appSecret) && !token) {
            throw new Error('token or appId/appSecret pair is required');
        }
        this.appId = appId;
        this.appSecret = appSecret;
        if (token) {
            return this.validateToken(token);
        }
        return new Promise(function (resolve, reject) {
            Logger_1["default"].trace("Initializing app with appId and appSecret", appId, appSecret);
            try {
                var grant = api_client_1.Grant.constructFromObject({
                    type: 'application',
                    appId: appId,
                    appSecret: appSecret
                });
                _this.authenticationApi.generateToken(grant, function (err, data) {
                    if (err) {
                        if (err.status && err.status === 401) {
                            var message = 'Combination of appId and appSecret is not valid.';
                            Logger_1["default"].info(message);
                            reject({
                                message: message,
                                internalError: err
                            });
                        }
                        else {
                            reject(ErrorHandler_1["default"].getError(err));
                        }
                    }
                    else if (data) {
                        _this.processTokenResult(data);
                        var accessToken = data.accessToken, expiresIn = data.expiresIn;
                        resolve({
                            accessToken: accessToken,
                            expiresIn: expiresIn
                        });
                    }
                    else {
                        reject(ErrorHandler_1["default"].getError());
                    }
                });
            }
            catch (e) {
                reject(ErrorHandler_1["default"].getError(e));
            }
        });
    };
    return OAuth2;
}());
exports["default"] = OAuth2;
