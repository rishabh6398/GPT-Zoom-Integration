export default class RealtimeApi {
    static isOffline: boolean;
    static networkConnectivityDispatcher: any;
    static setNetworkConnectivityDispatcher(networkConnectivityDispatcher: any): void;
    constructor(options: {}, oauth2: any, usePreviousGenerationResponses?: boolean, handlers?: {});
    id: any;
    usePreviousGenerationResponses: boolean;
    backoff: IEBackoff;
    webSocketUrl: string;
    options: {};
    referenceIds: any[];
    connect(onConnectCallback: any): Promise<void>;
    _connect(onConnectCallback: any, referenceId: any): Promise<any>;
    reConnect(reCheckNetworkConnectivity?: boolean): Promise<void>;
    onConnectWebSocket(): void;
    onErrorWebSocket(err: any): void;
    onMessageWebSocket(result: any): void;
    onCloseWebSocket(referenceId: any): (event: any) => void;
    onForceClose(referenceId: any): void;
    onStartedListening(message: any): void;
    onSpeechDetected(data: any): void;
    onRequestStart(message: any): void;
    onRequestStop(conversationData: any): void;
    onMessageResponse(messages: any): void;
    onInsightResponse(messages: any): void;
    onTrackerResponse(trackers: any): void;
    onTopicResponse(topics: any): void;
    onDataReceived(data: any): void;
    sendAudio(data: any): void;
    sendStart(resolve: any, reject: any): void;
    startRequest(): Promise<any>;
    oauth2: any;
    handlers: any;
    retryCount: number;
    requestStarted: boolean;
    conversationId: Promise<any>;
    conversationIdSuccess: (value: any) => void;
    conversationIdError: (reason?: any) => void;
    webSocketStatus: any;
    onConnectCallback: any;
    webSocket: WebSocket;
    requestStartedResolve: any;
    requestStoppedResolve: (value: any) => void;
    onRequestError(err: any): void;
    requestErrorReject: any;
    stopRequest(): Promise<any>;
    _cleanForReconnect(): void;
}
import IEBackoff from "./InverseExpBackoff";
import WebSocket from "../websocket/WebSocket";
