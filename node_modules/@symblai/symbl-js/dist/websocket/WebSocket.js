"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var websocket_1 = require("websocket");
var Logger_1 = __importDefault(require("../logger/Logger"));
var detect_node_1 = __importDefault(require("detect-node"));
var PING = "__PING__";
var PONG = "__PONG__";
var PONG_TIMEOUT_MS = 30000;
var PING_INTERVAL_MS = 30500;
var WebSocket = /** @class */ (function () {
    function WebSocket(options) {
        if (options === void 0) { options = {}; }
        if (!options.url) {
            throw new Error("url is required in the options.");
        }
        this.url = options.url;
        this.accessToken = options.accessToken;
        this.options = options;
        this.isConnected = false;
        this.pongTimeoutRef = null;
        this.pingIntervalRef = null;
        this.logEntries = [];
        this.connect = this.connect.bind(this);
        this.onConnect = this.onConnect.bind(this);
        this.onError = this.onError.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.onClose = this.onClose.bind(this);
        this.send = this.send.bind(this);
        this.disconnect = this.disconnect.bind(this);
        this.pongTimeout = this.pongTimeout.bind(this);
        this.ping = this.ping.bind(this);
        this.clearPongTimeout = this.clearPongTimeout.bind(this);
        this.clearPingInterval = this.clearPingInterval.bind(this);
        this.logRecurring = this.logRecurring.bind(this);
        this.connect();
    }
    WebSocket.prototype.ping = function () {
        var _this = this;
        if (this.webSocket.readyState === 1) {
            this.send(PING, null);
            this.pongTimeoutRef = setTimeout(function () {
                _this.pongTimeout();
            }, PONG_TIMEOUT_MS);
        }
    };
    WebSocket.prototype.pongTimeout = function () {
        Logger_1["default"].warn("PONG failed to receive in ".concat(PONG_TIMEOUT_MS, "ms, closing WebSocket connection"));
        this.clearPongTimeout();
        this.webSocket.close(3006, "Connection closure due to failure in receiving pong within configured threshold");
        this.options.onForceClose && this.options.onForceClose(this.options.referenceId);
    };
    WebSocket.prototype.clearPongTimeout = function () {
        if (this.pongTimeoutRef) {
            clearTimeout(this.pongTimeoutRef);
        }
    };
    WebSocket.prototype.clearPingInterval = function () {
        if (this.pingIntervalRef) {
            clearInterval(this.pingIntervalRef);
        }
    };
    WebSocket.prototype.onError = function (err) {
        if (!this.isConnected) {
            Logger_1["default"].error("Failed to establish the initial handshake: ".concat(err && err.message), err);
            return;
        }
        this.clearPingInterval();
        this.clearPongTimeout();
        this.options.onError
            ? this.options.onError(err)
            : function () { return Logger_1["default"].error(err); };
    };
    WebSocket.prototype.onMessage = function (payload) {
        // Incoming results for this connection
        var data = payload.data;
        if (data === PONG) {
            this.clearPongTimeout();
            return;
        }
        this.options.onMessage
            ? this.options.onMessage(data)
            : function () { return Logger_1["default"].debug(data); };
    };
    WebSocket.prototype.onClose = function (event) {
        if (!this.isConnected && event && event.code === 1006) {
            event.handshakeFailed = true;
        }
        this.clearPingInterval();
        this.clearPongTimeout();
        this.options.onClose
            ? this.options.onClose(event)
            : function () { return Logger_1["default"].info("Connection Closed."); };
    };
    WebSocket.prototype.onConnect = function (connection) {
        var _this = this;
        this.isConnected = true;
        this.webSocketConnection = connection;
        if (this.options.reconnectOnError) {
            this.pingIntervalRef = setInterval(function () {
                _this.ping();
            }, PING_INTERVAL_MS);
        }
        this.options.onConnectSuccess
            ? this.options.onConnectSuccess(connection)
            : Logger_1["default"].info("Connection established successfully");
        this.options.onConnect
            ? this.options.onConnect(connection)
            : Logger_1["default"].info("Connection established.");
    };
    WebSocket.prototype.connect = function () {
        var source = detect_node_1["default"]
            ? "js_sdk"
            : "web_sdk";
        var urlWithToken = "".concat(this.url, "?access_token=").concat(this.accessToken, "&source=").concat(source);
        this.webSocket = new websocket_1.w3cwebsocket(urlWithToken, null, null, {
            "X-API-KEY": this.accessToken
        });
        this.webSocket.binaryType = "arraybuffer";
        // TODO: Support for token in url
        this.webSocket.onerror = this.onError;
        this.webSocket.onmessage = this.onMessage;
        this.webSocket.onclose = this.onClose;
        this.webSocket.onopen = this.onConnect;
    };
    WebSocket.prototype.logRecurring = function (message, severity) {
        var _this = this;
        if (severity === void 0) { severity = "info"; }
        if (!this.logEntries[message]) {
            this.logEntries[message] = message;
            switch (severity) {
                case "warn":
                    Logger_1["default"].warn(message);
                    break;
                case "error":
                    Logger_1["default"].error(message);
                    break;
                case "debug":
                    Logger_1["default"].debug(message);
                    break;
                case "info":
                default:
                    Logger_1["default"].info(message);
                    break;
            }
            setTimeout(function () {
                delete _this.logEntries[message];
            }, 5000);
        }
    };
    WebSocket.prototype.send = function (data, cb) {
        if (!data) {
            cb && cb({
                "message": "undefined data detected."
            });
        }
        else {
            try {
                if (this.webSocket.readyState === 1) {
                    this.webSocket.send(data);
                }
                else {
                    this.logRecurring("WebSocket Connection not open. Couldn't send data.", "warn");
                }
            }
            catch (e) {
                Logger_1["default"].error("Error while sending the data.", e);
            }
        }
    };
    WebSocket.prototype.disconnect = function () {
        this.clearPingInterval();
        this.clearPongTimeout();
        this.webSocket.close(1000);
    };
    return WebSocket;
}());
exports["default"] = WebSocket;
